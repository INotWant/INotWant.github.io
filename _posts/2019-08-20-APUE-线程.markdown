---
title: "APUE 线程总结"
layout: post
date: 2019-08-20 11:55
tag:
- thread
category: apue
author: inotwant
description: APUE 线程综述
---

### 线程
1. 线程基础
    - 生命周期
        - `pthread_create`(创建)
        - `pthread_exit`(退出) `pthread_cancel`(取消)
            - `pthread_cancel_push` `pthread_cancel_pop`
                - 作用：指定在它们代码所在行间退出时的清理工作
                - 注1：它们是由宏实现的要成对出现
                - 注2：要注意期间用 `return` 退出时不会执行指定的清理。甚至，有些平台会出错
        - `pthread_join`
            - 获取制定线程的退出状态
            - 注：无法获取 *分离状态* 线程的退出状态
    - 线程属性
        - `detach`(分离状态) 
            - 被设置为分离状态的线程执行完成后立刻清理，无需递送退出状态(开发者已确定退出状态无意义) 
        - `stack`
            - 为线程指定新的栈地址&范围 
        - `stack_size`
            - 改变默认的栈大小
        - `guardsize`
            - 控制线程栈末尾之后用来避免栈溢出的扩展内存的大小
        - 注：以上属性存在于 `pthread_attr_t` 结构中
        - 可取消状态
            - `pthread_setcancelstate`
            - 作用：当设置为 `DISABLE` 时，则能阻塞 `pthread_cancel`；直至重设为 `ENABLE`，则到下一个取消点退出
        - 取消类型
            - `pthread_setcanceltype`
            - 作用：默认需要等到取消点才能退出，设为异步取消时只要有取消请求，立即退出
2. 线程同步
    - 互斥量
        - 独占式锁 :: 访问共享资源时先要获取锁，若锁已经被获取，要被阻塞，直至该线程能获取到锁
        - 避免死锁
            - 加锁有顺序(加锁有层次)
            - 细粒度锁改为粗粒度锁(权衡)
        - 属性
            - **进程共享属性**(Thread Process-Shared Synchronization)
                - 描述：可将互斥量设为可在多进程中使用
            - 健壮属性
                - 描述：与 *进程共享属性* 有关，解决持有互斥量的进程终止后互斥量恢复的问题
                - [使用](https://blog.csdn.net/red_knight/article/details/50417898)
            - 类型属性
                - `NORMAL`
                - `ERRORCHECK` --> 执行错误检查(比如，不占用锁时解锁、多次解锁)
                - `RECURSIVE`  --> 允许重入(递归锁)，亦支持错误检查
                    - 说明：在将单线程函数转为多线程时，`递归锁` 非常有用，但亦要谨慎使用
                - `DEFAULT`    --> 上面的某一种，由实现决定
        - 附：含超时版本
    - 读写锁
        - 共享式锁
        - 注：实现上可能会限制最大可同时获取读锁的次数，所以在获取读锁时要检查返回值
        - 属性(`pthread_rwlockattr_t`)
            - 进程共享属性
        - 附：含超时版本
    - 条件变量
        - 描述：将解锁互斥量(锁条件)与进入休眠状态这两个操作整合在一块形成一原子操作，关闭了这两个操作间的时间通道
        - 注
            - 1）用前先加锁，醒后重检查(重新检查条件是否满足，因为一次能唤醒多个阻塞)
            - 2）唤醒操作 `pthread_cond_signal`
        - 属性
            - 进程共享属性
            - 时钟属性 :: 指定超时采用是的哪个时钟
    - 自旋锁
        - 忙等获锁
        - 属性
            - 进程共享属性
        - 附：[自旋锁在抢占(或非抢占)单核和多核中的作用](https://blog.csdn.net/xhjcehust/article/details/26132167) 
    - 屏障
        - 描述：允许每个线程等待，知道所有的合作线程到达某一点，然后同时从改点继续执行
        - 属性
            - 进程共享属性
3. 线程安全
    - 描述：一个函数在相同的时间点可被多个线程安全地调用
    - 注：虽与信号处理程序中的函数可重入有类似概念，但线程安全函数不一定能可重入(异步信号安全)，反之亦然
        - 比如，要想带锁的线程安全函数可重入，需要锁为递归锁
    - 线程安全与IO(另，获取给定 FILE 对象关联的锁，即暴露锁)
        - `flockfile` `ftrylockfile`
            - 巧用，操作一个字符的不加锁版本 `getchar_unlocked` `putchar_unlocked`
4. 线程私有数据
    - 描述：同一个 key 不同线程绑定不同存储空间
    - 附：`pthread_once` --> 指定函数在所以线程中只执行一次(比如，用作key的初始化)
5. 线程与信号
    - 描述：每个线程都有自己的线程屏蔽字(创建线程时会继承)，但它们共用线程处理程序。此外，除了由与硬件故障相关的信号会发送至相关的线程中，其他信号则被发送至任意一个线程
    - 线程中信号处理模型
        - 同步 --> 指定专用线程去处理使用 `sigwait` 确定信号集
        - [进程、线程两种不同信号处理机制](https://blog.csdn.net/u012317833/article/details/39319155)
6. 线程与 fork
    - 1）POSIX 声明，fork 返回和子进程调用一个 exec 间子进程只能调用信号安全的函数
        - [原因](https://docs.oracle.com/cd/E19253-01/819-7051/gen-12013/index.html)
    - 2) 清除锁状态
        - `pthread_atfork`
            - 该方法设计的挺巧妙的，不能获锁(prepare指向的方法中)时，fork不能执行(阻塞，等待锁)
7. 线程和I/O
    - `pread` `pwrite` --> 将 `lseek` 与读写操作形成原子操作
