---
title: "SICP 构造数据抽象" 
layout: post
date: 2020-10-20 10:24
tag:
- sicp lisp
category: sicp
author: inotwant
description: SICP 数据抽象
---

### Chapter 2 构造数据抽象

从 "有理数的算术运算" 案例开始，假如有了有理数的 **构造函数** 和 **选择函数**（获取分子、分母），便可以方便地基于它们实现算术运算。这样的实现方式，实现了数据的 **表示** 和 **使用** 的分离，对有利于站在更高的层次编程、有利于后面的修改和增加了程序灵活性。

数据的表示和使用的分离，是一种分层抽象，每层的间隔被称为 **抽象屏障**。

那数据是什么？数据就是 **构造函数** 加上 **选择函数**？不全，这里还需要构造函数和选择函数结合满足一组特定条件，它们才能表示一套数据。有如此定义，那么下面它也表示一个数据，从中可以看到：**数据与过程再也无法区分！**

```lisp
; 数据的过程性表示
(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
    			((= m 1) y)
      		(else (error "Argument not 0 or 1 -- CONS" m))))
  dispatch)
(define (car z) (z 0))
(define (cdr z) (z 1))
; 附：要注意这种模式 --> "消息传递"
```

Lisp 中可用作构造任意种类的复杂数据结构的基本构建 -- **序对**（表结构）。序对有如此大的构造能力是因为它具备 **闭包**（注：闭包有另一含义表示“带有自由变量的过程的一种实现技术”） 性质 -- 序列的元素仍可为序列（Lisp 中的组合式也有这样的性质）。

在高阶过程的抽象中，可以抓住处理数值数据的一些程序模式，要想继续能在复合数据上做出类似抽象，则对我们操控数据结构的方式有着较深的依赖性。所以，这里引出了一种强有力的设计模式——**序列作为一种约定的界面**。序列作为约定的界面，可使得一系列计算过程表示为一些针对序列的操作，如此能帮助得到模块化的程序设计。以序列作为所用的统一表示结构，我们就能将程序对数据结构的依赖性局限到不多的几个序列操作上。常用的序列操作有：**累加器**、**过滤器**、**映射**。

> Richard Waters 研究发现某科学计算子程序包里，足足有 **90%** 的代码可以使用上述的设计模式。
>
> **嵌套映射**（多个 `map` 嵌套在一起）

<p align="right">-- 2020.10.16</p>

---

为了增强语言的表达能力，Lisp中还添加了 **符号数据**，使得能构造一种操作其他表达式的表达式。

> `'(a b c)` 是一个含 `'a` `'b` `'c` 三个符号的序列，其实它等价于 `(quote (a b c))` ，`quote` 作为一种特殊形式，它作用于后面的每个元素，并最终组成序列。
>
> `'()` 表示空表。
>
> `'(x (apple sauce) y apple pear)` ，其中 `(apple sauce)` 变换为 `(quote (apple sauce))` 。所以，最后为一内嵌序列。

符号数据的经典应用场景 —— **符号求导**。在此案例中可以看到，前面所提到的基于 **构造函数和选择函数** 构建的抽象屏蔽对于符号数据依旧适用。

**在一个程序的不同部分对一个数据往往存在不同的表示方式**，这便引出了数据抽象的又一要点：考虑数据的多种表示，隔离不同的表示方式。若把之前的抽象屏障作为一种水平的层次抽象，那么该种抽象作为垂直方向的隔离抽象。下图展示的通用型复数算术系统结构包含这两种抽象。

![表结构和基本机器算术](https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2020-10-20/表结构和基本机器算术.png)

**数据导向**，是基于类型进行分派。在每种表示的实现中，构造方法要为特定的表示添加 **标志**，而在选择方法中无需考虑数据中有该标注。因为通用方法通过该 **标志** 确定分派后，会把该标注 **剥离**。总的来说，在通用方法中根据数据的类型标志进行分派。(注：下图按行分解)

> 在书中，使用 Lisp 基于数据导向的复数算术包实现中，还体现了 **命名空间** ，把不同数据表示的方法实现在过程内部，使得它们具有局部性，避免了名字的相互冲突。

**消息传递**，是把数据表示为一个过程，使用时通过传递待执行的操作名称来实现分派。(注：下图按列分解)

![复数系统的操作表](https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2020-10-20/复数系统的操作表.png)

<p align="right">-- 2020.10.17</p>

---

设计一个 **通用型算术系统**（见下图），这里仍可使用 **数据导向的设计方式**，这里关键思想就是 *通过通用型界面过程，将描述数据操作的代码连接到几种不同表示上*。

此系统层面的通用型界面过程有：`add` `sub` `mul` `div`，还可以看到在其中的复数算术包中另含有下一层的通用型界面过程：`real-part` `imag-part` `...`。每个通用型界面过程下连接着几种不同的数据，往往使用类型标志来区分不同的数据。因而对于复数来说，它在此系统中存在两层类型标志，每进入下一层通用型界面便会剥去对应的类型标志。

此系统的通用型界面过程都是两个参数，这与之前的复数算术包略有不同。既有多个参数，便存在了不同类型数据组合的情况。现实也是合理的，比如，有理数和复数相加 `(add 有理数 复数)`。现考虑 **如何添加所有的不同类型数据的组合**。

- 一种原始的想法，为每种组合添加对应的操作过程。虽简单，但会破坏不同数据类型的完全分离（模块性）、影响可加性（添加一种新的类型需要兼顾之前的所有类型）。
- 一种解决方案是：**强制（类型）转换**（把一种类型的对象看作另一种类型的对象），若在进行分派时未找到与类型完全对应的过程，便可利用强制考虑能否把第一个参数类型的对象转换到第二个参数的类型，或反之，若可以，再去考虑分派。相较于原始的想法，如此做：**只需要为每一对类型写一个过程，而不是为每对类型和每个通用型过程写一个过程**。另一方面，还存在一些应用“强制”显得没那么一般。即使两种类型的对象不能互转，但转到第三种类型后可以计算。
- 另一种考虑类型间的关系更 “全局” 的解决方案是：**类型的层次结构**（“继承”）。对每个类型可“提升”至其超类型，并且可继承超类型的所有操作。这些可简化类型转换的复杂度。但其仍有不足，一个类型可能有多于一个的子类型、一个类型可能有多于一个的超类型。这意味着 **类的提升与下降过程可能涉及对整个类型网络的大范围搜索**。

由此可以看到，在设计大型系统时，处理好一大批相关的类型而同时又能保持模块性是一个非常困难的问题。作者认为：**如果没有知识表示和自动推理工作的帮助，这些问题是无法仅仅通过计算机语言设计的方式得到合理的处理**。

> 在面向对象语言中的大部分复杂性也来于此，就是对类型间通用型操作的处理。

![通用型算术系统](https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2020-10-20/通用型算术系统.png)

在通用型算术系统中添加 **一元多项式**。在多项式的运算中，我们使用通用型界面过程代替 Lisp 提供的基础运算符（如，`+`），这使得我们多项式的系数可以是系统中存在的任意类型，甚至可以是另一多项式。这样设计产生了 **数据导向的递归**，可大大提高表达能力，却几乎没增加复杂性。

总结数据抽象的几种方式：

- 基于 “构造过程” 和 “选择过程” 的基础数据抽象
- 把 **序列** 作为统一界面，致使高阶过程可用于复合数据的 “高阶” 数据抽象
- 隔离多种数据表示的数据抽象 --> (数据导向 & 消息传递)

<p align="right">-- 2020.10.20</p>

