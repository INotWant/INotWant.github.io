---
title: "SICP 构造过程抽象" 
layout: post
date: 2020-10-14 10:24
tag:
- sicp lisp
category: sicp
author: inotwant
description: SICP 过程抽象
---


### Chapter 1 构造过程抽象

Lisp 的创始人 -- 约翰·麦卡锡。

**计算过程** 往往由 **数据** 和 **程序** 组成。现存的许多威力强大的程序设计技术，都在填平 **数据** 和 **程序** 间的传统划分，即 **可将过程作为数据进行处理**（如此能带来一些灵活性）。

程序设计的基本元素：

- 基本表达式
- 组合式（指的是对表达式的组合，含 **运算符** 和运算对象）
- 抽象的方法

> 注：组合式的求值规则通俗来讲就是把参与的运算对象应用到运算符。这里的运算符有基本的，有方法定义得到的。另外，还有一些运算符被称为 “特殊形式” ，一般的求值规则不适用于它们。比如，`and` `or` 的短路、Lisp 中的 `define`。

要想运算符有意义需要 **环境** 的承载。

在按通用的求值规则对表达式求值时，可有两种执行顺序。它们分别为 **正则序** 和 **应用序**。正则序先执行 “运算符” ，等组合式中的表达式只剩基本表达式时再去求值；而应用序先执行各 “运算对象” 。可看到，正则序存在重复对某表达式求值的情况，所以性能要低于应用序。但，正则序这种处理方式有特别的价值，比如用于 **流** 的处理。

**函数与过程间的区别**：前者是在描述事情的特征，而后者是在描述如何去做这件事。即 **说明性知识** & **行动性知识**

Lisp 中无循环。

**牛顿法** 用于求根 <-- 证明：泰勒展开（利用函数上某点的信息去预估改点附近的点），不断往零点靠近

<p align="right">-- 2020.10.13</p>

---

再说过程，过程是一层抽象，它会屏蔽实现某功能的具体逻辑，在使用的时候把它当做 **黑箱** 即可。在过程的实现里，有自由变量和约束变量两种类型，约束变量具有局部性。另外，在过程实现里可定义局部过程等，它们的作用域仅限于该过程，这相当于 **命名空间**。

要想理解深入，就需要知道什么样的过程类型会产生什么样的计算过程。对于计算过程主要有：**递归计算过程** 和 **迭代计算过程**（指那种其状态可以用固定数目的状态变量描述的计算过程。如，一些高级语言中的循环）。上面已经提到，“Lisp” 中无循环，它是通过 **“尾递归”** 的方式实现迭代。因而，各种复杂的专用迭代结构变成不过是一些语法糖衣。

> 费马小定理：如果n是一个素数，a是小于n的任意正整数，那么a的n次幂与a模n同余数 --> 检验一个数是否是素数的 **概率算法**

再看高阶过程，高阶过程出现的需求：经常有一些同样的程序设计模式能用于若干不同的过程，换句话说，来抽象出一般性的计算方法。高阶过程有两种形式：**过程作为参数** 和 **返回过程**。

> 为了方便使用提供了 `lambda` 构成过程的方式：`(lambda (<formal-parameters>) <body>)` 。另外，`lambda` 的语法糖 `let` 可用于创建局部变量。为什么叫 `lambda` ，这是取自于 $\lambda$ 演算（数学家丘奇引进）

> 程序设计语言总会对 **计算元素** 的使用强加某些限制，带有最小限制的元素被称为具有 **第一级的状态**，它们具有以下“权利”：
>
> - 可以用变量命名；
> - 可以提供给过程作为参数；
> - 可以由过程作为结果返回；
> - 可以包含在数据结构中。
>
> Lisp 不像其他程序设计语言，它给了 **过程** 完全的第一级状态。这就给有效实现提出了挑战，但由此所获得的描述能力却是极其惊人。

**将一个计算过程形式化为一个过程，一般说，存在很多不同的形式，有经验的程序员知道如何选择过程的形式，使其特别地清晰且易理解，使该过程中有用的元素表现为一些相互分离的个体，并使它们还可能重新用于其他的应用。**

所以，**SICP**（Structure and Interpretation of Computer Programs）在讲什么，从上面来看，它在讲计算过程的构造。另外，前面还夹杂了对计算过程的解释的藐视，解释主要在后面章节讲。

<p align="right">-- 2020.10.14</p>

---

