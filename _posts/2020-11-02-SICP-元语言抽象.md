---
title: "SICP 元语言抽象" 
layout: post
date: 2020-11-02 10:24
tag:
- sicp lisp
category: sicp
author: inotwant
description: SICP 元语言
---

### Chapter4 元语言抽象

元语言抽象就是**建立新的语言**。

建立新语言是在工程设计中控制复杂性的一种威力强大的工作策略，我们常常通过采用一种新语言而提升处理复杂问题的能力。**因为新语言可能使我们以一种完全不同的方式，利用不同的原语，不同的组合方式和抽象方式去描述所面对的问题**。

事实上，我们几乎可把任何程序看作某个语言的求值器。比如，前面所描述的多项式运算系统、数字逻辑模拟器等，它们都有自己的基本元素，组合手段和抽象手段。从这一角度出发，处理大规模计算机系统的技术，与构造新的程序设计语言的技术有紧密的联系，而**计算机科学本身不过（也不更少）就是有关如何构造适当的描述语言的学科**。

故，本章讨论在一些语言的基础上构建新语言的技术。

#### 元循环求值器

元循环求值器，指**用与被求值的语言同样的语言写出的求值器**。下面将详细描述此求值器的原理。

首先明确求值器的作用：**求值器的工作并不是去描述语言的基本过程，而是提供一套连接方式，提供一些组合手段和抽象手段，借助于它们将基本过程联系起来**。从根本上说，元循环求值器也就是 **环境模型** 的 Lisp 表达形式。它包括两个部分：

1. 在求值一个组合式（非特殊形式的复合表达式）时，首先求值其中的子表达式，而后将运算符子表达式的值作用于运算对象子表达式的值 --> 组合手段
2. 在将一个复合过程应用于一集实际参数时，我们在一个新环境里求值这个过程的体。构造这一新环境的方式就是用一个框架扩充该过程对象的环境部分 --> 抽象手段

细看这两条规则，其实它描述了一个循环，也正是求值器的核心。在这一循环中，**表达式在环境中的求值被归约到过程对实际参数的应用，而这种应用又被归约到新的表达式在新的环境中的求值**，如此下去，直至下降到符号或者基本过程（它们直接在环境中找到意义）。

![求值器内核](./求值器内核.png)

由此我们可以得到求值器的内核（见上图），其包含两部分： `eval` 和 `apply`。`eval` 的参数是一个表达式和一个环境，其 **根据被求值表达式的语法类型分情况分派**。被求表达式有：基本表达式（数、变量）、特殊形式（`if` `lambda` `cond` `begin` 等）和组合式三种类型。对组合式的求解遵循上述的求值器的部分1，先递归运算对象，再递归求解运算符，最后使用 `apply` 把运算对象的值作为参数应用到运算符对应的值（过程）。而 `apply` 以一个过程和一个该过程应该去应用的实际参数的表作为参数，按参数中过程的类型去确定是要调基本过程还是要在新环境中执行过程体中的表达式。

求值器的基本骨架已确定了，现在就需要为骨架添加血肉。我们需要做以下内容：1）确定表达式的表示；2）确定求值器数据结构；3）启动前初始化环境以及提供“读入-求值-打印”驱动循环。

对于 **表达式的表示** ，我们可采用抽象的方式描述表达式类型的判定和对表达式各片段的选择。这种方式实质就是利用 **构造与选择函数** 使数据的表示和使用分离。如此，非常方便我们更换不同的语法表示。此外，还需要说明 **派生表达式**，它实质就是 **语法糖**，我们可把这种表达式翻译为已有表达式来求值。

对于 **求值器数据结构**，这里主要确定 **过程的表示** 和 **环境的表示和操作**。复合过程是由形式参数、过程体以及环境构成。另外，为了区分是语言基本过程还是自定义的过程需要在过程的表示中添加 **标志** 。而对于环境的表示和操作，需要把握**一个环境就是一系列框架的序列，每个框架都是一个约束的表格**。

对于 **求值器的环境初始化**，我们使用环境的操作创建一个初始环境，在其中建立起一些基本过程的名字与对应唯一对象的关联（Lisp 原生的支持对象）便可。

到此，元循环求值器已可成功运行。若把程序看成一种抽象的（可能无穷大）机器的一个描述，而这一求值器程序是以程序为输入，那么可把求值器看做一种 **通用机器**，它能模拟被描述机器的执行过程。这里更深刻地思想是，**任一求值器都能模拟其他的求值器**。这样，**有关 “原则上说什么可以计算” 的概念就是与语言或者计算机无关的了，它反映的是一个有关可计算性的基本概念**。**那什么是计算，即图灵机，任何“有效过程”都可以描述为这种机器的一个程序**。然而，并不是所有问题都是可计算的，比如 **“停机问题”**。

> 求值器是一个相对简单的过程，而它却能模拟比它本身要复杂的各种程序。**通用求值器的存在是计算的一种深刻而美妙的性质！！**

<p align="right">20.10.30</p>

上面得到的 **元循环求值器** 在处理 **内部定义** 时存在问题。**内部定义** 是指在过程内部定义的局部变量。上述的元循环求值器 **按定义出现顺序的一次一个名字的在环境中扩充**。这使得被定义的变量的作用域是 **从定义的位置开始至过程的结束** 而非整个过程。不过，我们可使用以下方式使内部名字的定义具有同样的作用域。在求值 lambda 表达式的体之前，首先扫描并删除掉这个过程体里的所有内部定义，并用 let 创建这些内部定义的变量，而后通过赋值设置它们的值。

 ```lisp
(lambda <vars>
        (define u <e1>)
        <e2>
        (define v <e3>))
# 被翻译成
(lambda <vars>
        (let ((u '*unassigned*)
              (v '*unassigned*))
             (set! u <e1>)
             (set! v <e3>)
             <e2>))
 ```

最后讨论有关元循环求值器的优化—— **语法分析与执行分离**，主要思想是把 `eval` 分割为两部分：第一部分 `analyze` 做语法分析，把每一表达式分析为一个以 **环境** 为参数的 `lambda` 过程。分析完成后，**原程序被翻译为等价的由一系列子 `lambda` 过程组合的 `lambda` 过程**；第二部分就是把 **环境** 参数应用到前面得到的 lambda 过程，即开始执行。可看到，**把程序（表达式）翻译成等价的执行过程的形式很巧妙**，值得借鉴。

<p align="right">20.11.02</p>

---

