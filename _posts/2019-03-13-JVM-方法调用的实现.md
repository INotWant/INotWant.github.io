---
title: "JVM 如何实现方法调用"
layout: post
date: 2019-03-13 17:00
tag:
- JVM
- Method-Call
category: JVM
author: inotwant
description: 深入理解 Java 虚拟机第八章阅读笔记
---

## JVM 如何实现方法调用

在 JVM 的方法调用实现中有两种常见的手段：`解析` `分派`。但它们并不是独立的，也就是 **在某个方法调用的实现过程中即用到了解析，又用到了分派**。

### 0. 准备
1. 变量的静态类型 --> 一个变量的静态类型不可变，即定义时指定的类型；
2. 变量的实际类型 --> 此变量某一时刻的相应类型（如为静态类型的子类），运行时可变；
3. `虚方法` 与 `非虚方法`
	- `虚方法` :: 其他方法
	- `非虚方法` :: `静态方法` `私有方法` `<init>` `父类方法` `final方法`（尽管使用 `invokevirtual` 调用）
	- `非虚方法` 一般指没法被继承的

### 1. 解析
1. 针对非虚方法，在编译期就确定了调用哪一方法
2. 注意，这里可能有以下误解：
	- 即使是在编译期确定了，但调用的方法仍表示为符号引用
	- 将符号引用转为直接引用仍是在类加载的 **解析阶段**

### 2. 分派
1. 静态分派
	- 用于实现 **重载** --> 由实参的静态类型确定
	- 本质：在编译期，根据变量的静态类型确定调用哪一方法
	- 实现：在编译器上（`javac`），并不是虚拟机执行的

2. 动态分派
	- 用于实现 **重写** --> 由接收者（即拥有此方法的对象）的实际类型确定调用哪个方法
	- 本质：在运行期间，根据 **操作数栈** 顶元素的实际类型决定调用哪个方法
	- 实现：虚方法表，在虚拟机中实现

3. 单分派 与 多分派
	- 宗量：方法的 `接收者` 与 `参数` 都可以称为宗量
	- 静态分派：多分派，由 `接收者` 与 `参数` 共同决定；
	- 动态分配：单分派，仅由 `接收者` 的实际类型决定；

4. 附：动态语言的特性之一
	- 变量无类型变量值才有类型

### 3. Other :: Java 与 动态类型
1. `MethodHandle` 的引入
	- 理解：方法句柄
	- 它与反射相比它是轻量级的，因为它在模拟的是字节码，而反射模拟的是Java代码
	- 更具备可优化性

2. `invokedynamic` 指令
	- 不同之处：将分派逻辑写在代码中
	- Lamada 表达式用此实现 
	- 《深入了解Java虚拟机上》p263 代码存在问题：[知乎答案](https://www.zhihu.com/question/40427344)

3. 类加载器 or 字节码生成 的应用
	- 类访问权限 -- Tomcat
	- 动态代理等
	- Java 逆向移植 -- `Retrotranslator`
	- 实战：实现远程服务器执行临时代码 

