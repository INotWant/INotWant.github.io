---
title: "如何更好地模拟世界" 
layout: post
date: 2020-10-27 20:48
tag:
- sicp lisp
category: sicp
author: inotwant
description: SICP 面向对象 流计算
---

### Chapter 3 模块化、对象和状态

在构造大型系统时，单单基于前面提到的 **数据抽象** 和 **过程抽象** 来设计是不够的，还需要一些有效的组织原则来指导我们系统化地完成系统的整体设计。**基于被模拟系统的结构去设计程序的结构** 就是一个强有力的策略，在此基础上又根据对于系统结构的两种非常不同的 “世界观” 可划分为：**基于对象的** 和 **基于流处理的**。

首先考虑 **基于对象的**。

我们对世界的常规观点之一，就是将它看作聚集在一起的许多独立对象，每个都有自己的随时间变化的状态，每个通过操作改变自身或者他人的状态。由这一思路出发，我们在程序中利用 **计算对象来模拟现实世界中的对象**，现实世界中的组织结构便能映射到程序中，如此能方便程序的模块化。

由于被模拟系统里的对象的状态是随着时间变化的，与它们相对应的计算对象的状态也必须变化。进一步看，我们要 **通过计算机里的时间顺序（计算对象的操作的相对顺序）去模拟现实系统里时间的流逝**。然而，我们无法仅利用前面所学的语言能力来表达随时间变化的状态，于是 **赋值运算符** 因缘而生。

> Lisp 中赋值表达式为： `(set! <name> <new-value>)` ，其中 `set!` 是个特殊形式，`<name>` 是个符号，`<new-value>` 是任何表达式。
>
> 把 `set!` 与局部变量相结合，形成了一种具有一般性的程序设计技术，就是用该技术去 **构造带有局部状态的计算对象**。

引进赋值的利益与代价

- 【利益】引进赋值后，我们可构造带有局部状态的计算对象（用局部状态变量去模拟系统的状态，用对这些变量的赋值去模拟状态的变化），可把状态封装在对象内部，无需把所有状态都显式地操作和传递额外参数。如此构造的过程更具一般性，有利于构造更模块化的系统。
- 【代价1】之前的过程计算模型——代换模型不适用了，需要考虑新的过程计算模型（即 **环境模型**）
- 【代价2】引入赋值后，过程不再等价于函数计算。并使得打破了引用透明性（“同一的东西可以相互替换”），因为计算对象的 **同一和变化** 的很难形式地定义，确定 **同一** 需要上下文（某些先验观念）。或者为对象添加一 **“标志”，它异于对象的状态**，当对象的状态随时间变化时，“标志”不会变化，因为变化前后仍是同一对象
- 【代价3】广泛采用赋值的程序设计被称为 **命令式程序设计**（之前的被称为 **函数式程序设计**），带有赋值的程序将强迫人们去考虑赋值的相对顺序，以保证每个语句所用的是被修改变量的正确版本。而在函数式程序设计中，根本不会有这类问题
- 【代价4】若考虑多个并发的进程，命令式程序设计的复杂性还会变得更糟糕

引入赋值后的新求值模型—— **环境模型**。在求值的环境模型里，一个过程被描述为一个过程对象，是一个对偶，包含 **代码** 和 **指向环境的指针**。环境模型可总结为下面两条规则：

- 将一过程对象应用于一集实际参数，将构造一个新框架，其中将过程的形式参数约束到调用时的实际参数，而后在构造起的这一新环境的上下文中求值过程体。这个新框架的外围环境就是过程对象所指环境。
- 过程只能通过 `lambda` 这种形式创建。那么对应过程对象的代码就是 `lambda` 的正文，指向的环境就是执行该表达式的环境。

> 注：通过画图模拟，能对环境模型有更深地了解。

<p align="right">20.10.21</p>

---

上一章提到基础的 “数据抽象” 是通过 **构造和选择函数** 来实现的表示和使用的分离。之前的数据是不能改变的，现在我们添加了赋值操作使得数据可随时间发生改变，被称为 **变动数据对象**。若针对变动数据对象仍使用构造和选择函数做抽象，则无法发挥数据变动的优势。在此，我们添加 **改变函数** 来完善针对变动数据对象的表示和使用分离的抽象。

就像上一章中，可使用序对组合成任意复杂的复合数据。针对变动数据对象，仍可使用添加了 **改变函数** 的序对来构成任意复杂的复合数据。为此，Lisp 中提供了 `set-car!` 和 `set-cdr!` 序对的两个基本改变函数。“共享和相等” 问题也伴随它们引入，从本质上看这一问题等价于引入赋值操作带来的 “同一和变化” 问题。只不过这里使用 **地址**（“指针”）来作为标志解决。再继续往深处想，**改变** 和 **赋值** 是什么关系。

> 从理论上说，为了表现变动数据的行为，所需要的全部东西也就是赋值。只要将赋值纳入这一语言，我们就引出了所有的问题，不仅是赋值，而且也包括一般性的变动对象。（注：我们可使用赋值基于 “消息传递” 实现变动的序对）
>
> 从实现观点，赋值要求我们去修改环境，而环境本身也是一个变动数据对象。这样，赋值和变动就具有同等的地位，可相互实现。

有了可变动的序对后，我们可构造更复杂的数据结构。比如，**队列**、**表格** 等等，在这里我们可联想在其他高级语言中所利用的数据结构。注：在创建一复杂的数据结构时，首先考虑它的 **构造函数**、**选择函数** 和 **改变函数**。

**数字电路的模拟器** 案例，设计一个执行数字逻辑模拟的系统，这一系统是被称为 **事件驱动的模拟** 程序的典型代表，在这类系统里，一些活动引发另一些在随后时间发生的事件，它们又会引发随后的事件，并如此继续下去。

思考如何设计，系统总体采用面向对象的方式，现实中的对象在系统中映射为对应的计算对象，主要有：**线** 、（反、与和或门，几个基本功能部件）。考虑每个对象的表示，可从 **构造函数**、**选择函数** 和 **改变函数** 出发。

另外，还需思考的重中之重是，如何实现事件的驱动（传播）。这类模拟系统的一种实现方式是：**维护一个待处理表来存储一系列待处理任务，这些任务按执行时间排序。某事件的触发可能向待处理表中添加一任务。而我们要模拟系统运行时，只需按序执行待处理表的任务，任务的执行可能触发另一事件，进而可能向待处理表中添加一任务。待处理表中所有任务执行完成，则模拟系统完毕。**这里，**线** 对象含 *信号值* 和 *一组过程* ，这些过程多为所连接构件注册上的。当信号值发生变化时（事件触发），会调用该组过程。过程根据其中逻辑（对应构件的逻辑）判断是否会触发另一事件，若有则把它添加至待处理表中，待合适时机再触发。

再回看被模拟的数字电路系统，我们可以用一种 “新” 语言来描述它，各种基本功能块形成了这个语言的基本元素，将功能块连接起来就是这里的组合方法，而将特定的连接模式定义为过程就是这里的抽象方法。是不是有 **DSL** 的味道！--> 其中，**线** 在很大程度上起着 ~~**组合**~~ **传播**的作用。

<p align="right">20.10.22</p>

---

**约束系统** 案例，整个系统描述了一些变量间的关系（比如，`9C = 5(F - 32)`），给约束系统输入一些已知变量的值（比如，给定 `F` 的值）可得出未知变量（比如，现可得出 `C` 的值）的值。由此，可看到约束系统的最大特征是 **非定向计算**。

思考如何设计。先可以列出整个系统具备的功能，然后再去设计。整体上仍采用基于对象的模拟方式，此系统具备两种基本的对象：**约束对象** & **连接器对象**。约束对象具体有：乘法约束、加法约束和常量约束等。约束对象的主要职责就是，当事件发生时（连接器上有新值），根据所设定逻辑检查能否推出或更新已绑定连接器中的某一连接器的值。若可以，则为对应连接器设置新值，之后通过连接器往系统传播这一变化（注：P199 上方有关传播（计算）方式的描述更具体、清晰）。可以看到，**连接器对象** 的主要作用就是 **传播**。传播的方式就是，某约束被连接器连接就需要在此连接器上注册一过程，当此连接器有新值了，就去调用这一过程。这与上面 **数字电路模拟器中的连线** 的作用非常相似。 值得一提的是，这些对象非常适合使用消息传递的方式构建。

再回看约束系统，它也算是一种 **DSL** 应用，利用一种 “新” 语言去描述系统。但，写于此，突然对哪些是语言中的基本元素、哪些是组合有了不同的认识。就拿数字电路的模拟器来说。现又认为，**连线** 作为语言中的基本元素，而 **基本构件** 作为组合方式。这一想法与之前的想法（**基本构件** 作为语言中的基本元素，而 **连线** 主要起组合作用），应该都不对。**它们都是 “新” 语言的基本元素，而这一新语言的组合方式和抽象方法直接借用的 Lisp 的**。

下面讨论有关赋值的最后一个话题：并发。

> 这里也可说是有关带有局部状态的计算对象（变动数据对象）的话题，还可以说是面向对象的话题。因为引入赋值的目的就是构建具有局部状态的计算对象，然后再用它去模拟现实世界中随时间变化的对象。

上面在介绍引入赋值带来的问题中已提到：在并发程序中，命令式程序设计（与 “函数式程序设计+赋值” 等价）的复杂性会变得更糟糕。那么什么是并发，为什么要应用并发以及为什么复杂性变得更糟糕。下面一一解答这些问题。

下面是并发的定义，通俗地说，计算机具备的（或“看似”）可同时运行多个程序的特性。并发的出现，一方面是因为处理器的发展方向从主频的提升更替为更多的核心，由此并发能提高性能带来速度优势；另一方面是因为现实世界里的对象并不是一次一个地顺序变化，与此相反，我们看到它们总是并发地活动，所有东西一起活动。所以，用一集并发执行的计算过程模拟各种系统是很自然的，将计算模型划分为一些能各自独立地并发演化的部分，常常也很合适，也可能使程序更模块化。

> 在[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中，**并发性**（英语：Concurrency）是指在一个系统中，拥有多个计算，这些计算有同时执行的特性，而且他们之间有着潜在的交互。因此系统可进行的运行路径会有相当多个，而且结果可能具有不确定性。[并发计算](https://zh.wikipedia.org/wiki/并发计算)可能会在具备[多核心](https://zh.wikipedia.org/wiki/多核心)的同一个芯片中复合运行，以[优先分时](https://zh.wikipedia.org/wiki/优先权)[线程](https://zh.wikipedia.org/wiki/线程)在同一个处理器中运行，或在不同的处理器执行。 --  摘自《维基百科》

在程序（进程）中，变动数据对象随代码的执行而改变，这模拟了现实世界中随时间变化的对象。在并发程序中，存在共享的变动数据对象，也就是多个进程都要访问或修改的数据对象。从并发的定义中可看到，多个进程的运行路径不定，也就是进程间的代码无序执行（进程内有序），而恰巧我们是通过代码的执行前后来模拟时间的前后。如此，并发执行造成了 **时间混乱**！所以说 **“并发：时间是一个本质问题”**。虽然并发会造成时间混乱，但在大多数情况下不会对结果产生影响。只有遇到共享变动数据对象时，因存在非原子性的逻辑，才会出现脏数据，产生错误的结果。

保证并发程序正确行为的方式（对程序的并发执行增加一些限制）

- 规定，修改任意共享状态变量的两个操作都不允许同时发生
- 保证并发系统产生出的结果与各个进程按照某种方式顺序运行产生出的结果完全一样（不要求各个进程顺序地运行，只要求结果同即可）
- 不需要对于共享变量的并发使用提出任何限制 --> 无论有关的操作按什么顺序执行，这种算法都能收敛到正确的解

> Lisp 中使用 **串行化组** 实现这种限制，同一串行化组里面的过程不能同时被执行。究其实质，串行化组是通过互斥量（独占锁）实现的，在调用一过程时，入加锁出释放。

究竟是什么原因导致在并发程序中引入赋值带来如此的复杂性。是程序语言本身的问题？不是。事实上，可能就是物理世界中最基本的复杂性的一种反映。考虑这一场景，古时有一钱庄，它在全国各大城市都有分社。假如某人他在A分社存了一部分钱，他以很快的速度又（或者他的亲人）到了B分社来取钱。那么，B分社能有效知道他能取多少吗，A分社和B分社的数据已经同步了吗。暂不考虑，这一钱庄的解决方案，但这种 “共享状态” （通信）问题在现实世界中本来就存在。那计算机在现在起到了什么作用。它只不过是把之前的一些解决方案自动化了，并且能以更快地速度完成通信。

<p align="right">20.10.25</p>

---

下面讨论 **流**，前面说到引入赋值后可构建具备局部状态的计算对象来模拟现实对象，使得程序更模块化，但引入赋值会带来很多困扰。考虑一种新的观测现实世界的角度，能否屏蔽那些带来的缺点，而不失程序的模块化。**基于流** 的程序设计是一种好的解决方法。因为引入赋值会带来问题的根本原因是：它利用求值发生的顺序来模拟现实世界中的时间，而在基于流的程序设计中把时间分成一个个的小时刻，流中元素表示对应时刻的对象状态，这样整个流就可表示对象的变化。或说之，**用序列去模拟变化，以这种序列表示被模拟系统随着时间变化的历史** （流可被看成序列）。

在数据抽象中提到，“ **序列** 可作为统一界面，致使高阶过程可用于复合数据的高阶数据抽象”，但直接使用序列存在性能问题。现在，使用流仍使得我们可利用各种序列操作，但不会带来把序列作为表去操作而引起的代价。这因为 **流的构造和它的使用能够交错进行，而这种交错又是完全透明的**。

流通过 **延时求值** 技术来实现 **构造和使用的交错进行**。（对于常规的表，其 `car` 和 `cdr` 都是在构造时求值；而对于流，其 `cdr` 则是在选取的时候才去求值）

```lisp
(cons-stream <a> <b>) # 等价于 (cons <a> (delay <b>))
(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))
# 附：`cons-stream` `delay` 必须是特殊形式，要不 <b> 表达式会被求值
(delay <exp>) # 只不过是在外面添加了一层语法糖衣，被翻译成如下 (lambda () <exp>)
# 附：对 `delay` 的实现有种优化 --> 带记忆
(define (force delayed-object) # 即调用
  (delayed-object))
```

**流** 甚至可表示无穷长的序列。这里有两种构建无穷长的流的方式：**递归过程**（描述“生成”过程） **递归定义**（隐式地定义流）。无论采用哪种方式构建无穷流，**它们可行是只用到了已生成的部分**。

```lisp
## 使用 递归过程 定义无穷流（以“埃氏筛”为例子）--> 求素数
# 通过下面的定义可看到利用递归过程构造无穷流主要是认识到过程调用与子流的关系
(define (integers-starting-from n)
  (cons-stream n (integers-starting-from (+ n 1))))
(define (sieve stream)
  (cons-stream
   (stream-car stream)
   (sieve (stream-filter	# sieve 递归调用
           (lambda (x)
                   (not (divisible? x (stream-car stream))))
           (stream-cdr stream)))))
(define primes (sieve (integers-starting-from 2)))

## 隐式定义无穷流 --> 求素数
# 下面是一种隐藏定义是因为在 prime? 中又用到了 primes
(define primes
  (cons-stream 2 (stream-filter prime? (integers-starting-from 3))))
(define (prime? n)
  (define (iter ps)
    (cond ((> (square (stream-car ps)) n) true)
      ((divisible? n (stream-car ps)) false)
      (else (iter (stream-cdr ps)))))
  (iter primes)) # 此处又用到了 primes
# 可借助 p229 中的表格形式来理解
```

上面已介绍 **流** 能够构造和使用交替地进行的原因是利用了 **延时求值** 技术，此延时求值技术对使用者来说是隐藏的（隐藏的 `delay` `force`）。而在某些带有循环的系统的流模拟上，可能还需要直接使用 **延时求值** （即直接使用 `delay` `force`）。如，`(define y (integral (delay dy) y0 dt))` 其中 ` (delay dy)` 是延时求值的直接使用。

显式地使用 `delay` 和 `force` 能够提供很大的编程灵活性，但这种做法可能会导致程序变得更加复杂。因为那样的话，过程可被分为两类：**常规的过程** 和 **要求延时参数的过程**。**如果创建了不同种类的过程，就将迫使我们同时创建不同种类的高阶过程**。一种解决方案是：让所有过程都用延时参数，构造一种求值器使其所有参数都自动延时，即采用 **正则序** 。但，这将会对设计依赖于事件顺序的程序的能力造成极大损害。当时，**变动性** 和 **延时求值** 在程序设计语言里结合得非常不好。

**流计算** 模式的使用：

- 系统把迭代操作方式表示为流过程，用序列表示值的变化。这样做的好处是可使用**加速器**

- **流为模拟具有内部状态的对象提供了另一种方式**。用流表示对象状态的时间史。流时间显式地表示了出来，因此松散了被模拟的世界里的时间与求值过程中事件发生的顺序之间的紧密联系

> 在基于流实现的 “取款处理器” 中，它以一个余额值和一个提款流作为输入，是一个具有良好定义的数学函数，输出完全由输入确定。但用户看到的却是在与一个改变着状态的系统交互。消除这种悖论的方式是，正是由于用户方的时态的存在，为这个系统赋予了状态特征。若以余额流的方式思考，而不是去看个别的交易，这个实现看上去就是无状态的了。

基于对象的方式去模拟现实世界是很自然的，然而这种方式也把现实世界中有关时间的复杂度带到了模型中，会产生同步多个进程等棘手的问题。避免这些问题的可能性推动着 **函数式程序设计语言** 的发展。在这种语言中，所有过程实现的都是它们的参数上的定义良好的数学函数，其行为不会变化。函数式途径对于处理并发系统特别有吸引力。

但，有时与时间有关的问题也潜入到函数式模型之中（P248例子）。它并没有完全解决与时间相关的所有问题。

总结：本章的目标就是构造一些计算模型，使其结构能够符合我们对于试图去模拟的真实世界的看法。**我们可以将这一世界模拟为一集相互分离的、受时间约束的具有状态的相互交流的对象，或者可以将它模拟为单一的、无时间也无状态的统一体。**每种观点都有其强有力的优势，但就其本身而言，有没有一种方式能够完全令人满意。我们还在等待一个大一统的出现。

> 当“对象”之间不共享的状态远远大于它们所共享的状态是，对象模型特别好用。
>
> 将对象观点与函数式观点合并可能与程序设计的关系不大，而是与基本认识论有关的论题。

<p align="right">20.10.27</p>