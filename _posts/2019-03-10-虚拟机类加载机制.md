---
title: "虚拟机类加载机制"
layout: post
date: 2019-03-10 11:42
tag:
- JVM
- JAVA
- classloader
category: JVM
author: inotwant
description: 深入理解 Java 虚拟机第七章阅读笔记
---

## 虚拟机类加载机制

下图描述了虚拟机中类加载的整个过程，主要包括：加载、链接、初始化。

![虚拟机类加载过程](https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2019-03-10/classload_process.png "类加载过程")

首先有两点注意：
1. 此处是 **类** 加载的过程，勿理解为 **对象**。所以，加载的信息是要保存在 **方法区** 中的。
2. 此外，需要注意的是这几个步骤虽然有先后关系，但并不是等前一个步骤完全结束后才开始下一步。也就是说它们有重叠。

现在大概清楚了类加载的过程，紧接着考虑类加载的时机。

### 0. 类加载时机

当且仅当出现下面五种情况之一时，虚拟机才会尝试加载相应的类：
1. 创建该类相应的对象实例时，要访问该类的静态方法、静态变量（非常量）时，此类未曾加载过，则会加载此类；
2. 在加载类的过程中，发现此类的父类未曾加载，则会先去加载其父类；
3. 创建该类的 `Class` 对象（使用该类的反射）时，如果发现此类未曾加载，则会去加载此类；
4. 程序的入口 `main()` 方法所在的类，会首先被加载； 
5. 当使用 `java.lang.invoke.MethodHandle`（JDK1.7 引入）获取该类的方法句柄时，如果发现此类未曾加载，则会先去加载此类；

以上五种引用，如果发现待引用的类未曾加载，则会先去加载相应的类。因此，这些引用被称为 **主动引用**。而，其他的引用一般不会引起类的加载，所以通常称为 **被动引用**。

接下来将简洁地描述每个步骤的内容，用以结束这部分的学习。

### 1. 加载

这一步主要完成下面三个目标：
1. 通过一个类的全限定名来获取此类的二进制字节流；
2. 将这些静态结构的字节流转化为方法区的运行时数据结构；
3. 在内存生成一个代表这个类的 `java.lang.Class` 对象，作为方法区这个类的各种数据的访问入口。

这里创建的 `java.lang.Class` 对象在内存中的位置，在不同的 `JVM` 实现中往往不一样。尽管对象实例一般存储在 *堆* 中，但是在 `hotspot` 实现中把它放在了 *方法区* 中。

可以看到，这里只点出了类存在的形式（*二进制字节流*），没有限定它的来源。换句话说，根本没有指明要从哪里获取、怎样的获取。所以，它可以来源于 `Class文件` `zip包` `网络流` 等，甚至可以 `运行时计算生成`（*动态代理*）。*Java 发展历程中，充满创造力的开发人员则在这个“舞台”上玩出了各种花样，许多举足轻重的 Java 计数都建立在这一基础之上。* **（借鉴）**

具体上面的怎么实现，其实很简单，只要 **自定义类加载器** 就可以了。

附：`代码分发`

### 2. 验证

首先，在验证阶段可以检查访问权限、类完整性等待。其次，虽然使用纯粹的 Java 语言无法破坏虚拟机，但是不代表 **字节码** 不可以。所以，验证阶段对于虚拟机的安全是非常重要的。

验证阶段主要完成以下验证：
1. 文件格式验证；
2. 元数据验证（`StackMapTable` *栈图*）；
3. 符号引用验证（涉及动态链接，一般结合解析阶段）；

### 3. 准备

准备阶段的目标很简单，就是为 **类变量**（*静态变量*）分配空间、赋予零值。

### 4. 解析

解析阶段完成的任务是动态链接，也就是将 **符号引用** 转化为 **直接引用**。通俗的说，符号引用只是个代名词，而直接引用是目标的 *指针*、相对偏移或一个能间接定义到目标的 *句柄*。

可以这样理解 **动态链接**。Java 程序是由一个一个类组成的，在类的方法中往往要调用其他的方法（此类的或其他类的）。考虑如何实现方法的调用呢？（只考虑如何查找到目标方法）Java 中是这样做的：它为每一个方法做标识（符号引用），这些标识显然与内存分布无关。然后，在编译得到的 Class 文件中保存了这些标识。当有方法调用该类的方法（使用符号引用指明调用哪个方法）时，会首先加载此 Class 文件。在加载的过程中，会得知方法的内存位置（直接引用）。所以，JVM 就记录了 **符号引用** 对应的 **直接引用**。这样，刚刚的方法调用就知道调用的方法的入口地址了。

### 5. 初始化

类初始化阶段时类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载其参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。

它对应的时 `<clinit>()`。这里初始化包括两部分：**类变量赋值** **静态代码块**。

最后说明一点，不像普通的构造方法，`<clinit>()` 在多线程环境中被正确地加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 `<clinit>()` 方法。

---

## 一、双亲委派模型
0. 准备
	- **类加载器** 的概念；
	- 由 **类加载器** 和 **类** 唯一确定一个 **类**（热替换使用此）；

1. 什么是双亲委派模型
	- 加载一个类时，首先要递归地用 **父类加载器** 加载；
	- 当加载失败时，最后才调用该类的类加载器去加载。

> 下面是 Java 中，类加载器的结构。

2. 双亲委派模型的意义
	- 这样的模型天然具备含优先级的层次关系，使得 Java 标准库的最基本行为得到保障；

## 二、双亲委派模型的破坏
1. JDK 1.2 之前（因为双亲委派模式是在 JDK1.2 之后提出的）；
2. 基础类去调用 `SPI`(Service Provider Interface) 代码 --> 线程上下文类加载器；
3. 模块部署、热替换等技术，对程序动态性的追求所导致；
	- **只要有足够意义和理由，突破已有的原则就可认为是一种创新。**

#### 参考

[深入理解 Java 虚拟机](https://item.jd.com/27158085978.html?extension_id=eyJhZCI6IjE0NzYiLCJjaCI6IjIiLCJza3UiOiIyNzE1ODA4NTk3OCIsInRzIjoiMTU1MjE4OTc1MSIsInVuaXFpZCI6IntcImNsaWNrX2lkXCI6XCIxMDAxYTI5Yy00ZjA2LTRjMjQtOGYxMy0xOGY4YTJkYjAwMjBcIixcIm1hdGVyaWFsX2lkXCI6XCI5MDI2MTYxNjg3NDAyNTk2MTE0XCIsXCJwb3NfaWRcIjpcIjE0NzZcIixcInNpZFwiOlwiMzMyZjJlNzctMjBhNS00MmY1LTlhNzgtYTc5ZWNlYjQyMTg5XCJ9In0=&jd_pop=1001a29c-4f06-4c24-8f13-18f8a2db0020&abt=0)
