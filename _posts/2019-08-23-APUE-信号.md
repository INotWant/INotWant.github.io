---
title: "APUE 信号总结" 
layout: post
date: 2019-08-23 20:36
tag:
- signal
category: apue
author: inotwant
description: APUE 线程综述
---

### 信号
1. 什么是信号（软中断）
    - 信号源
        - 某些硬件错误发生后，硬件检测到通知内核，内核使用信号通知相关应用程序
        - 其他略
    - 信号是一种典型的异步模型
    - 附：硬中断的理解
2. 信号的继承
    - `fork` 后都继承
    - `exec` 后忽略屏蔽继承、处理程序无法继承（代码区都换了）
    - 新线程继承原有的信号屏蔽字
        - 在多线程下，信号处理常使用同步模型，即安排专门的线程处理信号
3. 从不可靠到可靠信号
    - 不可靠特征
        - 不能保证信号一定能送达
        - 无法阻塞
        - 信号处理程序重置问题
    - 可靠信号
        - 一定送达
        - 可阻塞信号
            - **未决的信号**（如，给挂起的进程发送信号、阻塞的信号）
        - 信号排队（取决实现）
4. 慢速系统调用被信号中断
    - 慢速系统调用
        - 管道、终端设备、网络的读写
        - `pause` `ioctl` 等操作
        - 磁盘的读写不是
    - 能否重启
        - 可通过 `sigaction` 设置由某信号中断的系统调用是否重启
5. 可重入函数（异步信号安全）
    - 注意与 *线程安全* 区分
    - 可重入函数：一般指的是那些能在信号处理程序中调用的函数（比如，`malloc` `free` 因使用静态数据不允许，非可重入函数）
6. 一些系统调用
    - kill raise(给自己发信号)
    - alarm pause
        - alarm 定时器（使用 SIGALRM 信号，故每个进程只有一个）
        - pause 挂起进程直至捕捉一个信号
        - 注：在使用它们实现 `sleep` 时，存在一种竞争：在 alarm 后 pause 前，SIGALRM 信号到达，从而导致最后永久阻塞
            - 解决1）使用 `longjmp` `setjmp` 但还存在问题
                -  问题1）jmp 会提前结束之前为完成的中断
                -  问题2）jmp 回到 main 后，信号屏蔽字可能未恢复
                    -  解决：使用 `siglongjmp` `sigsetjmp` 替代（多了一个参数用以指定是否要恢复信号屏蔽字）
            - 解决2）使用 `sigsuspend` *（原子地恢复信号屏蔽字使进程休眠）*
    - sigprocmask(设置信号屏蔽字)
    - sigpending(查看当前未决信号)
    - sigaction(`signal` 替代品)
    - abort(自己终结自己(SIGABRT信号)，意图清理)
    - sleep nanosleep clock_nanosleep
        - nanosleep 并不是使用 SIGALRM 信号实现，事实上它不涉及产生任何信号
    - sigqueue(信号排队)

附：
- `system` 实现先屏蔽 `sigchild` 的原因
>> 如果该函数的调用者在其SIGCHLD信号处理函数中调用了waitpid函数来获得任意子进程的终止状态，且在fork之前没有阻塞SIGCHLD信号，则子进程结束，父进程执行SIGCHLD信号处理函数且得到了子进程的终止状态。而该函数中的waitpid函数由于没有得到其创建的子进程的终止状态而出错。

