---
title: "一个简单的编译器前端【记】" 
layout: post
date: 2021-03-06 20:48
tag:
- 编译原理 龙书
category: 编译原理
author: inotwant
description: 编译器前端
---

### 一、目标

程序员所用的语言与计算机直接能识别的语言一般是存在鸿沟的。可认为 **汇编语言** 是计算机能直接识别的语言，而为了便利程序员一般采用像 **C** **Java** 这种高级语言。**低级语言与高级语言间的鸿沟**是由谁来弥合的？**编译器**！本文通过一个简单的例子来说明 **高级语言** 翻译至 **低级语言** 的大概过程。

换句话说，要把一个 **自定义的简单高级语言** 翻译成三地址码（**类汇编代码**）；

下面的 **[上下文无关文法](https://www.zhihu.com/question/21833944)** 定义了该高级语言：

```
program -> block
block -> {decls stmts}
decls -> decls decl | ∈
decl -> type id;
type -> type[num] | basic
stmts -> stmts stmt | ∈
stmt -> loc = bool;
     | if(bool) stmt
     | if(bool) stmt else stmt
     | while(bool) stmt
     | do stmt while(bool);
     | break;
     | block
loc -> loc[bool] | id
bool -> bool || join | join
join -> join && equality | equality
equality -> equality == rel
				 | equality != rel
         | rel
rel -> expr < expr
		| expr <= expr
    | expr > expr
    | expr >= expr
    | expr
expr -> expr + term
		 | expr - term
     | term
term -> term * unary
		 | term / unary
     | unary
unary -> ! unary
		  | - unary
      | factor
factor -> (bool)
		   | loc
       | num
       | real
       | true
       | false
```

下面的代码可由上述的上下文无关文法推出，所以这一代码属于该高级语言，从而本文最终实现的程序能把它翻译成对应的三地址码。

```c
{
    int i;
    float[100] a;
    float v;
    while(true) {
        do i = i + 1; while (a[i] < v);
    }
}
/* 由上述文法推导出上述代码的过程：
 * 1) program -> block
 * 2) block -> {decls stmts}
 *		2.1) decls -> decls decl
 * 				 ...
 * 		2.2) stmts -> stmts stmt
 *				 stmts -> ∈
 *				 stmt -> while (bool) stmt
 *				 2.2.1) bool -> join
 *								...
 *				 2.2.2) stmt -> do stmt while (bool);
 *								...
 */
```

至于 **三地址码**，通俗的讲它包括 **操作符** 和 **运算符** 两部分，**三地址** 表明一条中至多有三个运算符。比如，

- `z = a + b`，被认为是一个三地址码，其中 `a` `b` `z` 是运算符，`+` 是操作符
- `z = - a`，被认为是一个三地址码，其中 `a`  `z` 是运算符，`-` 是操作符

上述代码被翻译成 **三地址码** 为：

```
// 注：声明性的语句不会体现在三地址码中
L_00:
	ifFalse true goto L_01
L_02:
	T_00 = i + 1
	i = T_00
	T_01 = a[i] < v
	ifTrue T_01 goto L_02
	goto L_00
L_01:
```

###二、翻译过程概述

翻译过程分两个阶段：

- **词法分析**，格式化输入，使得后续处理的是 **token流** ，而不是 **字符流**
- **语法分析**，以 **token流** 作为输入，先生成对应的 **抽象语法树**，再去得到 **中间代码** （即三地址码）

### 三、词法分析

1）确定语言中所涵盖的 **token** 有哪些类型

- 字典
  - **id**
  - **true false** **if else while break do**
  - **num** **real**
  - **basic => (int float double char bool)**
  - **=** **(** **)** **[** **]** **{** **}**  **>** **<** **+**  **-** **\*** **/** **!** **&** **|** **;**
  - **||** **&&** **==** **!=** **<=** **>=** 
- 类图

<img src="https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2021-03-06/lex.png" alt="Package lex" style="zoom:60%;" />

2）分析过程：不断地扫描字符，采用方法较简单

### 四、语法分析

#### 先生成 **抽象语法树**。采用 **预测分析法**，一种自顶向下的方法，该方法需要文法满足一定条件

1）消除 **左递归**（预测分析法需要文法中无左递归）

```
program -> block
block -> {decls stmts}
decls -> decl decls | ∈
decl -> type id;
type -> basic typeRest
typeRest -> [num] typeRest | ∈
stmts -> stmt stmts | ∈
stmt -> loc = bool;
     | if(bool) stmt
     | if(bool) stmt else stmt
     | while(bool) stmt
     | do stmt while(bool);
     | break;
     | block
loc -> id locRest
locRest -> [bool] locRest | ∈
bool -> join boolRest
boolRest -> || join boolRest | ∈
join -> equality joinRest
joinRest -> && equality joinRest | ∈
equality -> rel equalityRest
equalityRest -> == rel equalityRest
					   |  != rel equalityRest
             |  ∈
rel -> expr < expr
		| expr <= expr
    | expr > expr
    | expr >= expr
    | expr
expr -> term exprRest
exprRest -> + term exprRest
				 |  - term exprRest
         |  ∈
term -> unary termRest
termRest -> * unary termRest
				 |  / unary termRest
         |  ∈
unary -> ! unary
		  | - unary
      | factor
factor -> (bool)
		   | loc
       | num
       | real
       | true
       | false
```

- 注：左递归意味 **左结合性**，消除了左递归在处理时不要忘记左结合性。另外需要注意的是，上述文法在设计时便考虑了表达式的 **优先级**。

2）确定抽象语法树的结点表示（类图）

![Package parse](https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2021-03-06/parse.png)

- 注：`Rest` 结点设计的不好，表示的意义不太具体，不如《龙书》附录给出的实现中采用的 `And` `Or` 等一系列类（类属性中能含本类对象）

3）为每个产生式创建对应的函数，函数中模拟产生式

- 注：需求产生式头部的 **FIRST 集**

- 在 `Block` 产生式对应的函数中涵盖 **符号表** 的构建，**符号表** 是为了 **结合变量的 声明 与 使用**

#### 得到 **抽象语法树** 后，通过在 **每个结点添加一系列动作的方式**（即 **语法制导** 方式）来生成三地址码

1）结点分为两种 **语句** & **表达式**

- 语句翻译较易，需注意的是，`break` 语句需得知外围的循环对象。所以在抽象语法树构建时，遇到循环对象时先无参构建，以便其内部的 `break` 能够得到此对象
- 表达式的翻译需要区分 **左值** & **右值**；另外，一些表达式还包括跳转；此外，一难点就是对数组访问的处理

#### 补充

1）**类型检查/自动类型** 转换可穿插在其中

2）对比自己的实现与《龙书》所给的实现，最大的感触是 **封装** 与 **解耦**

### 五、结果展示

```
// 输入
{
    int i;
    int j;
    float[100] a;
    float v;
    float x;
    while(true) {
        do i = i + 1; while (a[i] < v);
        do j = j - 1; while (a[j] > v);
        if (i >= j) break;
        x = a[i];
        a[i] = a[j];
        a[j] = x;
    }
}
// 输出
L_00:
	ifFalse true goto L_01
L_02:
	T_00 = i + 1
	i = T_00
	T_01 = a[i] < v
	ifTrue T_01 goto L_02
L_04:
	T_02 = j - 1
	j = T_02
	T_03 = a[j] > v
	ifTrue T_03 goto L_04
	T_04 = i >= j
	ifFalse T_04 goto L_06
	goto L_01
L_06:
	x = a[i]
	a[i] = a[j]
	a[j] = x
	goto L_00
L_01:
```

### 六、参考

- [《编译原理》第二版](http://bestcbooks.com/B001NGO85I/) —— 第二章

