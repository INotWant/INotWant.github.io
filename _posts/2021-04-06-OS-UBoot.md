---
title: "OS Uboot" 
layout: post
date: 2021-04-06 10:24
tag:
- OS U-boot
category: OS
author: inotwant
description: OS Uboot
---

# U_boot

### 目标

制作一个U启动，使得计算机从U盘引导时，可把U盘指定目录下（`boot` 目录）的指定文件（`kernel`）加载至内存，并由此执行。

即，实现以下启动流程：

1. 把 OS 的 `kernel` 拷贝至U盘的 `boot` 文件夹下，并重命名 `kernel 文件` 为 `kernel`

2. 重启电脑，选择从U盘引导

3. 电脑最后将把U盘中的 `kernel` 加载至内存并运行。如此，可从物理主机上运行自写的 OS

### 准备

一些有关U启动的基础知识请参考 -> [U启动版的 “HelloWorld”](https://blog.csdn.net/kiss_xiaojie/article/details/114857081)

由上述文章，已得到一个分区格式为 `MBR` 并含一个文件系统为 `FAT32` 的分区的U盘。

下面实现在此基础上展开。

### 实现

实现要点

- 详细了解 `FAT32` 文件系统的结构，清楚如何去定位（查找）文件夹、文件
- 确定如何把U盘存储的内容加载至内存（`CHS` or `LBA`）
- X86 处理器的模式切换（由 **实模式** 切换至 **保护模式**）
- 确定 `bootloader`（即，查找文件夹、文件，运行模式切换等逻辑）存储至U盘的位置
- 确定内存布局（即，`FAT表` `bootloader` 等加载至内存的位置）

#### 1. FAT32 文件系统

当前U盘从第0个扇区开始存储布局如下图所示：

![u_layout](https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2021-04-06/u_layout.png)

最前面的MBR只占一个扇区，其内部主要包含一些引导逻辑和分区信息。在 [U启动版的 “HelloWorld”](https://blog.csdn.net/kiss_xiaojie/article/details/114857081) 中已详细介绍并修改好了MBR的内容，当前不用修改。另外，需注意的是**MBR后面存在一些未使用的保留扇区**，这些保留扇区的后面才是**DBR**。

从 DBR 开始一直到数据区的结束，都属于 `FAT32`，也就是：

![FAT32](https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2021-04-06/FAT32.png)

从 [FAT32文件系统结构详解](https://blog.csdn.net/li_wen01/article/details/79929730) 可详细了解各个部分的内容以及作用。这里的目标是查找指定的文件夹（`boot`）、文件（`kernel`）。所以，只需重点了解 **文件分配表** 和 **目录项**。

查找逻辑概括为：

1. 先定位到 **数据区**，数据区的第一簇存储了 **根目录**，把该簇加载至内存
2. 根目录是由多个 **目录项** 组成。一般来说，一个目录项索引一个文件或文件夹。所以，开始遍历根目录的目录项查找是否存在 `boot` 文件夹对应的目录项
3. 若查找到，从对应目录项中可得知 `boot` 文件夹所在的簇号，把该簇加载至内存（替换内存中的 **根目录**）
4. 遍历 `boot` 文件夹的目录项，从中查找 `kernel` 文件对应的目录项
5. 若查找到，从对应目录项中可得知 `kernel` 文件所在的簇号，后续把此簇加载至内存中的指定位置

注意，若目录或文件较大，会占多个簇。此时，可通过查看 **FAT表** 确定当前簇是否为最后。所以，在上述的查找逻辑中还应包括查看 **FAT表** 的逻辑，用于确定目录或文件是否到达最后。

#### 2. 实现查找逻辑

##### 2.1 CHS 与 LBA

把U盘内容加载至内存，一般使用 [`int 0x13, ah=0x02`](https://stanislavs.org/helppc/int_13-2.html) ，它以扇区为单位加载。该中断需要指定两个地址：1）通过柱面号、磁头号以及扇区号指定把U盘的哪一位置的内容加载至内存；2）通过线性地址指定加载至内存的哪里。后一地址按下不表，先看前一个地址。

通过柱面号、磁头号以及扇区号定位扇区，被称为 `CHS`。一般情况下，柱面从零开始编号，每个柱面含 `255` 个磁道；磁头号亦从零开始编号，每个磁道含 `63` 个扇区；扇区从 **1** 开始编号。还有另一种方式，被称为 `LBA`，它更简单且有效，即从零开始依次为扇区编号。`CHS` 与 `LBA` 的转换公式为：

![CHS_LBA](https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2021-04-06/CHS_LBA.png)

[此处](http://www.zhenhuaguo.info/zhenhuaguo/NonHtmlArticles/html_format/CHS_LBA.htm) 有关于 CHS 与 LBA 更详细的介绍。因为 `LBA` 更简洁，所以代码中涉及U盘地址的都用 `LBA` 表示，只有要去使用 `int 0x13, ah=0x02` 读取时，才需把 `LBA` 地址转换为 `CHS` 地址。 

##### 2.2 一些常量

在实现时，还需要初始化以下常量，后续它们被用于地址计算：

- DBR 所在的扇区，即 DBR 的 LBA 地址		--> 从 MBR 的 DPT 中获取
- FAT 所在的扇区，即 FAT 的 LBA 地址 	     --> 等于 DBR_LBA + DBR后面的保留扇区数（从DBR 中获取）    
- DATA 所在的扇区，即 DATA 的 LBA 地址   --> 等于 FAT_LBA + 2*FAT所占扇区数（从DBR 中获取）  
- 每簇所含扇区数                                              --> 从 DBR 中获取

注：这些常量的初始化在 `dbr_boot.asm` 源码文件中，下面代码中把它们作为已知常量使用。比如，`DBR_LBA_OFFSET` 是一个内存的地址，它指向的内存存放着 `DBR_LBA` ，所以代码中 `[DBR_LBA_OFFSET]` 为 DBR 所在的扇区。

##### 2.3 查找 `boot` 文件夹的代码

```assembly
; desc: 从根目录项查找 boot 文件夹
; 返回：
;   存在，则返回对应簇号（ax）
;   不存在，输出错误信息，进入死等
find_boot_dir:
    mov ax, 0x02											 ; ax 为根目录的簇号
    find_boot_dir_new_cluster:
        push ax
        mov bx, DIR_OFFSET
        call read_cluster_to_memory

        mov cx, [BYTE_PER_CLUSTER_OFFSET]
        add cx, DIR_OFFSET             ; cx 为 簇 加载至内存的最大边界
        mov ax, DIR_OFFSET

    find_boot_dir_loop:
        cmp ax, cx
        je find_boot_dir_end
        mov bx, ax
        cmp byte [bx], 0x00             ; [目录项第一个字节] 0x00
        je find_boot_dir_error
        cmp byte [bx], 0xE5             ; [目录项第一个字节] 0xE5 表示该目录项已被删除
        je find_boot_dir_next
        cmp byte [bx + 0x0B], 0x0F      ; [目录项第 0x0B 字节] 0x0F 表示长文件
        je find_boot_dir_next
        mov bl, [bx + 0x0B]
        and bl, 0x10
        cmp bl, 0x10                    ; [目录项第 0x0B 字节] 第3bit 为 1 表示此文件项代表文件夹
        jne find_boot_dir_next

        ; __START 比较文件名
        mov esi, BOOT_DIR
        mov edi, 0
        mov di, ax
        mov ecx, 5
        cld
        repe cmpsb
        cmp ecx, 0
        jne find_boot_dir_next
        ; __END__

        pop bx
        add ax, 0x1A
        mov bx, ax
        mov ax, [bx]
        ret
        find_boot_dir_next:
            add ax, 0x20
            jmp find_boot_dir_loop
    find_boot_dir_end:
        pop ax
        call next_cluster
        cmp ax, 0xFFFF
        jne find_boot_dir_new_cluster
    find_boot_dir_error:
        mov bx, NOT_FIND_BOOT
        call print
        call print_nl
        jmp $

; desc: 把 lba 转为 chs
; 参数：dx:ax 存 lba
; 返回：
;	CH = track/cylinder number  (0-1023 dec., see below)
;	CL = sector number
;	DH = head number
lba_2_chs:
    mov bx, SECTOR_PER_CYLINDER
    push dx
    push ax
    div bx                  ; ax 柱面
    mov ch, al
    shl ah, 0x06
    mov cl, ah              ; ch（柱面的低 8 位），cl（7-6bit，柱面的高 2 位）
    pop ax
    pop dx
    mov bx, SECTOR_PER_TRACK
    push dx
    push ax
    div bx
    add dl, 1               ; dl 扇区
    add cl, dl              ; cl（5-0bit，扇区）
    pop ax
    pop dx
    mov bx, SECTOR_PER_TRACK
    div bx
    mov bl, TRACK_PER_CYLINDER
    div bl                  ; ah 磁头
    mov dh, ah
    ret

; desc: 由簇号获取 LBA
; 参数：ax 存簇号
; 返回：
;   簇号对应起始扇区的 LBA（dx:ax）
cluster_lba:
    sub ax, 2
    mov bh, 0
    mov bl, [SECTOR_PER_CLUSTER_OFFSET]
    mul bx
    mov bx, [DATA_LBA_OFFSET]
    add ax, bx
    adc dx, 0x00
    ret

; desc: 获取指定簇号的下一簇号
; 参数：ax 存簇号
; 返回：
;   下一簇号（ax），若为 0xFFFF 则表明结束
next_cluster:
    push ax
    mov bl, 0x80
    div bl
    mov ah, 0x00
    add ax, [FAT_LBA_OFFSET]
    mov dx, 0x00
    call lba_2_chs
    mov ax, 0x00
    mov es, ax
    mov bx, FAT_OFFSET
    mov al, 0x01
    mov dl, [BOOT_DRIVE_OFFSET]
    call disk_load
    pop ax
    mov bl, 0x80
    div bl
    mov al, ah
    mov bl, 0x04
    mul bl
    add ax, FAT_OFFSET
    mov bx, ax
    mov ax, [bx]
    ret

; desc: 把指定 簇 加载至内存中的指定位置
; 参数：
;   ax -> 簇号
;   bx -> 指定加载至内存的位置
read_cluster_to_memory:
    push bx
    call cluster_lba
    call lba_2_chs
    mov ax, 0x00
    mov es, ax
    pop bx
    mov al, [SECTOR_PER_CLUSTER_OFFSET]
    mov dl, [BOOT_DRIVE_OFFSET]
    call disk_load
    ret
```

注：从 boot 文件夹查找 `kernel` 文件以及把 `kernel` 加载至内存的逻辑与上述实现大同小异，具体实现请参考 `bootloader.asm` 源码文件。

#### 3. 从 实模式 切换至 32位保护模式

X86 的 CPU 启动后运行的模式为 **实模式**，这种模式下只能使用 20 位的地址线，所以寻址空间为 0~1M。所以，为了访问更大的空间这里需要切换至 **32位保护模式**。在保护模式下，寻址空间可达 4GB（2^32）。

此外，这两种模式下的寻址方式也不同：

- 实模式 --> 段寄存器 << 4 + 段偏移地址
- 保护模式 --> 段选择子 + 段偏移地址

详情，请参考 [x86汇编语言：从实模式到保护模式](https://www.kancloud.cn/digest/protectedmode/121465)

从实模式切换至 32位保护模式，主要流程：

1. 设置 `GDT`
2. 把 `cr0` 寄存器的第 0 位置 1
3. 使用 `jmp` 指定，设置 `cs` 寄存器以及清空指令缓存，正式进入保护模式

注，具体实现请参考 `gdt.asm` 和 `switch_pm.asm` 源码文件

#### 4. 确定 `bootloader` 存储至U盘的位置

再次明确一下 `bootloader` 执行的流程：

1. 查找 `boot` 文件夹；若找到，再从 `boot` 文件夹中查找 `kernel` 文件
2. 若找到，把 `kernel` 文件加载到指定内存
3. 从 `实模式` 切换至 `32位保护模式`
4. 跳转内核处执行，开始运行内核

实现上述所有功能的 `bootloader` 编译后大约有 800+ 字节，而 DBR 的引导部分只有 420 字节。所以，需要对 `bootloader` 拆分。拆分的思想很简单，把 `bootloader` 拆分成两块，一块只含较少逻辑（称之为**小块**），另一块含剩下的绝大部分逻辑（称之为**大块**）。在 DBR 的引导部分只存放小块外加把大块加载至内存的逻辑。而 **大块** 被存储在U盘的 **DBR后续的几个保留分区** 中。

实现时，对 `bootloader` 的拆分如下：

- 小块，只含 2.2 小节所述的常量的初始化 --> 对应 `dbr_boot.asm` 源码文件
- 大块，含查找并加载 `kernel` 文件、模式切换等逻辑 --> 对应 `bootloader.asm` 源码文件

此外，实现时把大块置于 DBR 后的第2和第3个扇区

#### 5. 内存布局

DBR 会被加载至内存的 `0x7c00` 处（**规定**），后续呢？下图一目了然

![](https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2021-04-06/memory_layout.png)

#### 6. 代码

[全部代码](https://github.com/INotWant/os/tree/lisp_asm/u_boot)

### 参考

[1] [x86汇编指令集大全（带注释）](https://blog.csdn.net/bjbz_cxy/article/details/79467688)

