---
title: "Java 运行时数据区"
layout: post
date: 2019-02-12 21:20
tag:
- JVM
- memory
category: JVM
author: inotwant
description: 深入理解 Java 虚拟机第二章阅读笔记
---

## 引言

如何深入了解一门语言呢？当然我们会想到有很多点去切入。这里想说的是关于 **内存** 这一点。为什么要考虑 **内存** 呢？有个显然的例子，我们在写 C 时很容易出现 *内存泄漏*。那我们怎么才能避免？除了细心外，对 C 的运行时内存了解是必不可少的。这样，我们才能知道什么时候需要申请内存，哪些内存需要释放。

虽然，Java 提供了 `GC` ，但是难免也会有内存泄漏和内存溢出等问题。所以，我们想深入 Java 时，了解它的运行时内存区域也是必要的。当然，认识 Java 运行时数据区也是学习 `JVM` 的必由之路。

## Java 内存区域

![JMM](https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2019-02-12/java-memory-model.png "Java 运行时数据区")

1. 程序计数器
	- 线程私有
	- 作用：记录下一次执行的字节码行号
	- 异常：无
2. 虚拟机栈
	- 线程私有
	- 作用：存储一个一个的栈帧，而每一个栈帧的出、入栈操作对应相应方法的调用、返回过程
	- 栈帧：局部变量表（**`栈内存`**）、操作数栈、动态链接、方法出口
	- 异常：`StackOverflowError` & `OutOfMemoryError`
3. 本地方法栈
	- 线程私有
	- 作用：同 **虚拟机栈**
	- 异常：`StackOverflowError` & `OutOfMemoryError`
4. 方法区
	- 线程共享
	- 作用：保存类的元信息（类信息、常量、静态变量）、JIT编译后的代码以及运行时常量池（字面量和符号引用）。JVM规范上称其为逻辑堆，股其亦需要GC（较难）。GC的目标主要是针对常量池的回收和对类型的卸载
	- 别名：`Non-Heap`(非堆)、~~`Permanent Generation`(永久代)~~
	- 认识：`String.intern()`，此方法之前是将指定字符串（当该字符串首次出现时）复制到方法区再返回新的对应引用（JDK6之前）。现在，此方法不再执行复制，常量池中存储的是指定字符串首次出现的对象引用，且方法的返回值即为该引用。下一节将有该方法的例子
	- 异常：`OutOfMemoryError`
5. 堆
	- 线程共享
	- 作用：存储对象 **实例** 及 数组
	- 别名：`GC堆`（从这里可以看出GC对堆的重要性）
	- 异常：`OutOfMemoryError`
	- 对象实例（其大小必须为 8 字节的整数倍）
		- 对象头：`Mark Word`（哈希码、GC分代年龄、锁等，32 or 64 bit） + 对象类型（不一定有，数组长度）
		- 实例数据
		- 对齐填充
6. 直接内存
	- 线程共享
	- 作用：不属于JVM虚拟机规范中定义的内存区域，它是Java代码使用Native函数库直接分配的堆外代码。多用于NIO，避免了在Java堆和Native堆中来回复制数据，提高了性能。
	- 异常：`OutOfMemoryError`

附：
1. `CAS`（比较并设值）
	- 一种原子操作
	- 从另一个角度看，它代表了一种思想 -- **乐观锁**
	- 操作：其有三个操作数：地址、假象值、新值。如果对应地址中的真实值等于假象值，则用新值覆盖。否在，不更改。最终返回相应地址的真实值（old）。
2. 指针 & 句柄
	- 通过句柄访问，是一种间接访问，至少进行2次访问内存。句柄中包含对象的地址。
	- 直接指针访问

## 实战 OOM

1. Java 堆溢出 --> `java.lang.OutOfMemoryError: Java heap spae`
	- 分析：分析 Dump ，重点确认内存中的对象是否有必要存在。以便确定是 `Memory leak` 还是 `Memory overflow`。
2. 两栈溢出
	- 分析要点：如果是线程太多造成的溢出，则可以通过 **减少栈容量** 来解决！
3. 方法区溢出
	- 方法区的溢出也较常见：
	- 1）类的卸载条件比较苛刻
	- 2）越来越多的语言动态性（需要动态构造大量类）
4. 本机直接内存溢出
	- 分析要点：OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO ，则很有可能是这方面的原因。
