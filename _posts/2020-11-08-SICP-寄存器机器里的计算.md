---
title: "SICP 寄存器机器里的计算" 
layout: post
date: 2020-11-08 20:48
tag:
- sicp lisp
category: sicp
author: inotwant
description: SICP
---

### Chapter5 寄存器机器里的计算

终于来到了这一章！这次阅读  `SICP` 的目的就是为了写一个 **Lisp 解释器** ，所涉及的大多是本章的内容，但为了更好地理解选择了重头开始刷。不管怎么说，历经千辛万苦终于可迈入门槛了。。。

本章的流程可概括为：首先考虑 **如何设计运行特定程序的寄存器机器**；接着为了更好地理解 **寄存器机器的运行** 使用 Lisp 过程模拟寄存器机器；然后便可思考如何设计**运行 Lisp 解释器的寄存器机器，即把 Lisp 求值器程序变换为寄存器机器的描述**；最后研究了一个简单的**编译器**，它能将 Lisp 程序翻译为指令的序列。

#### 如何设计运行特定程序的寄存器机器

开始讨论之前，先明确 “寄存器机器” 是什么。寄存器机器顺序地执行一些指令，对一组固定称为 **寄存器的存储单元** 的内容完成各种操作。

要设计一部寄存器机器，需要设计好它的 **数据通路** 和 **控制器**。数据通路描述了这一机器需要哪些 *寄存器*、*操作* 以及 *是如何连接* 的，非常像是此机器的 **线路图**。而 **控制器** 给出了数据通路图中一些操作的顺序，要想得到预期的结果就需要按照控制器所描述的顺序执行。

目前，我们更想理解控制器里的指令，而 **数据通路图** 加 **控制器** 的方式，使得指令不易阅读。还有一种特定寄存器机器的描述方法，**把 “数据通路描述” 置于 控制器序列中**。这种方式与 **汇编** 非常类似。

在 **控制器** 中，常用的指令有：`assign` （给寄存器赋值） `test`（添加测试） `branch`（根据测试结果决定是否跳转） `perform`（执行动作） `goto`（无条件跳转）等。其中，为了复用数据通路，引入了跳转指定。为了复用控制器，扩充了寄存器 `assign` 指令与 `goto` 指令的能力。assign 允许将控制器序列里的标号作为值赋给寄存器，goto 可从一个寄存器的内容所描述的入口点继续下去。

>  **动作**：一些操作会产生一种效果，但这种效果却不是我们所设计的机器的一部分（指不影响数据通路图中的构建），这类操作被称为动作。比如，`print`。

把我们之前简单的 Lisp 程序转为由寄存器机器描述，还差考虑 **递归** 的实现。两个字便可概括总体思想：**堆栈**。在遇到递归子程序时，只要某些寄存器的值在子问题求解完成后还需要，就把它们的当前值存入堆栈。而后去求解递归的子问题，再恢复保存起来的寄存器值，并继续执行原来的主程序。另外，`continue` 寄存器的值必须保存。因而，控制器中又引入了两个有关堆栈的指令：`save` `restore`。

#### 寄存器机器模拟器

首先需要明确此寄存器机器模拟器的功能：**它能够根据已规定好的用于描述寄存器机器设计的语言去模拟（产生）对应的寄存器机器**。所以，要想得到具备某特定功能的寄存器机器必须先有该特定寄存器机器的语言描述，而后需要把此描述作为寄存器机器模拟器的输入。所以说，**它只能在有描述下才能去产生特定的寄存器机器**。

我们再来确定特定寄存器机器需要哪些描述。其实，上面已 “隐约” 给出具体的描述是什么。上面提到我们可用 *含数据通路描述的控制器序列* 来描述一特定寄存器机器。所以，具体的描述为：**寄存器** **操作** **控制序列**。实质上，寄存器和操作就基本决定了**数据通路图**。

是时候考虑此模拟器的实现了。模拟器能根据所给的描述模拟相应的寄存器机器的运行。所以，模拟器最本质的工作是**把控制序列解释成对应的 Lisp 程序，然后使得可执行**。上面已给出控制序列中要支持的几个指令，据此，需要我们的模拟器中提供 **寄存器** 和 **堆栈** 的实现。

有关 **寄存器** 和 **堆栈**，我们可直接使用 **消息传递** 的方式来实现。

接下来是关于 **解释** 的实现。在解释一开始需要扫描所有指令，构建指令表（是以 指令文本 和 对应的执行过程 组成的序对作为元素的表）和标号表（是以 标号 和 标号所关联一个指到指令表里的指针 组成的序对作为元素的表），这是为实现转移指令做准备。在解释的过程中，把每条指令封装成无参执行过程。这与 `4.1.7` 节中的 `analyze` 比较像。至于每个指令如何转换成对应的无参执行过程，此处不再详述。究其实质，**解释** 的实现非常像前面研究过各种**求值器**——它有一个输入语言，以及对于这一语言里的每个类型必须执行的适当动作。

#### 显示控制的求值器

此处将会把之前用 Lisp 描述的求值器修改为使用 **寄存器机器的描述**。之所以被称为显示控制的求值器，是因为其中的参数传递和函数值返回都是由自己实现。

由于求值器是由一种描述变为另一种描述，所以它的逻辑骨架不变，这里仍分为 `eval` 和 `apply`。不同的是需要自己控制过程的调用。我们需要一些寄存器的辅助：`exp`（表达式） `continue`（存放返回的位置） `proc`（指运算符）`env`（指环境） `argl`（指参数） `unev`（起辅助作用）。其实把求值器的 Lisp 描述转为寄存器机器的描述的过程比较简单，只要注意 **堆栈** 的使用便可（过程调用的实现）。 

> 注：为了简单，有关环境和过程对象的操作以及语法的构建和选择的操作都被作为寄存器机器的基本操作。

另外，值得说明的是 **尾递归** 的实现。此处的尾递归指的是一种能仅使用常量空间利用递归代替迭代的技术。为了实现这种技术，我们只需要**在求值一个序列里的最后一个表达式时，求值器直接跳转到 `eval-dispatch`，不把任何信息存入堆栈**。

#### 存储分配和废料收集

上面思考显示控制求值器的实现时，把有关环境和过程对象的一些操作都作为寄存器的基本操作，而若在真实机器上实现时我们不得不考虑它们。其中有关表存储结构（序对）的实现是一个非常基础的问题。**因为任何复杂的数据结构都可由序对组成**。本节就是考虑序对的实现和GC。

序对的实现如下图：

![表存储结构的实现](https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2020-11-08/表存储结构的实现.png)

其中，`the-cars` 与 `the-cdrs` 是两个连续的存储空间。`the-cars` 存储的是对应索引的 `car` 部分，而 `the-cdrs` 存储的是对应索引的 `cdr` 部分。另外，值得一提的是每一部分存储的是 **数据类型**  + **数据**。此外，还需要一个指针，它总是保存着下一个可用的下标。

根据上面的描述，我们已经可以很容易实现 **表的基本操作**（`car` `cdr` `cons` `set-car!` `set-cdr!` `eq?`）。有了表，我们便可基于它去实现 **堆栈** （堆栈在寄存器机器里起着重要作用，用于实现 递归），实现方式比较简单用表来模拟就可以了。在实际中，堆栈另行分配为一个 **单独的向量** 有很大优越性，对于堆栈的压入和弹出操作 **只需通过增加或减少向量下标** 的方式实现。
