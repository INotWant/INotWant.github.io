---
title: "Java 自动内存管理"
layout: post
date: 2019-02-15 21:24
tag:
- JVM
- GC
category: JVM
author: inotwant
description: 深入理解 Java 虚拟机第三章阅读笔记
---

Java 与 C 之间存在自动内存管理一堵墙，墙里面的人（Java）想出来，墙外面的人（C）想进去。

Java 自动内存管理涵盖两个方面 **内存分配** 和 **垃圾回收**，也就对应着动态内存的 *申请* 与 *释放*。下面我们从这两个方面来了解这堵墙。

## 垃圾回收

如何去了解一个新事物呢？在哲学上有相关的方法论。具体是什么，不能再扯了，要不就扯远了。所以呢，这里认识 **垃圾回收(GC)** 也是有步骤的。

#### 1. GC 的目标 
从字面意义理解它，就是把无用的抛弃留足空间给未来。这里可以想象一下，创造 GC 的动力（脑补自己写 C 时小心翼翼申请、释放动态内存的画面）。

可以看到，GC 不是针对所有内存的。只有 `方法区` `堆` 中的内存才有被 GC 的可能。而对应 `虚拟机栈` `本地方法栈` 等内存它们都是线程私有的，并且随着入栈、出栈等操作会自动申请、释放。（如果对 `方法区` `堆` 等名词不了解，在 [Java-运行时数据区](https://www.inotwant.top//Java-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/) 中有介绍）

现在，我们对 GC 有了新的认识。GC 是针对 `方法区` `堆` 的内存进行操作的，当出现对应区域中内存不足时，它能够释放无用内容所占的空间为新内容提供充足的空间。

方法区中无用内容主要包括：废用的常量 和 已卸载的类。已卸载的类需要满足以下三个条件：1）无对应实例；2）无对应 Class 对象；3）加载该类的 ClassLoader 已经被回收。在大量使用反射、动态代理、GCLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这种频繁自定义 ClassLoader 的场景，方法区的 GC 能力对整体性能有着关键性影响。

堆中无用的内容就是已死的对象了。如何去判断对象是否存活，如何执行回收动作。下面将以堆中的 GC 为例，进一步认识 GC 的过程。

#### 2. 判断对象存活算法

引用计数法
- 原理：为每一个对象维护一个值，记录此对象被引用的次数。当引用次数为 0 时，表明该对象已死
- 问题：很简单，但存在对象间相互引用问题

可达性分析
- 原理：维护一个森林（多个树），每一个结点为一个引用。能从 `GC Roots` 到达的结点指向的对象都是存活的，堆中的其他对象已死。
- `GC Roots` 有哪些
	- 1）虚拟机栈中的对象引用
	- 2）本地方法栈中的对象应用
	- 3）方法区中的常量、静态变量

![可达性分析](https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2019-02-15/gc-roots-trees.png "可达性分析")

#### 3. 清理对象算法

标记-清除（Mark-Sweep）
- 原理：第一次遍历内存标记出需要清除的位置，第二次遍历内存时清除被标记的
- 缺点
	- 1）效率低耗时
	- 2）内存碎片

复制方法
- 原理：将内存等分为两部分，分配内存时先只使用其中某一部分。当被使用的部分无可用空间需要 GC 时，将该部分存活的对象复制到另一个部分，并且接下来的分配使用此部分。可以看到，此方法交换使用两个内存片
- 问题
	- 1）浪费了内存。解决，分成三部分：`Eden` `survivor` `survivor`。此时，每次可用空间大小为：`Eden` + `survivor`
	- 2）当把内存分为三部分，GC 时会出现无法保存存活对象的能力（内存不够用了）。解决，分配担保，即借用老年代的空间
	
标记-整理
- 原理：第一次遍历内存标记出需要清除的对象，接着让存活的对象移动到某一段
- 优势：解决了内存碎片问题

分代收集算法
- 原理：将内存分成两部分。一部分放置易无用的对象（朝生夕死），另一部分放置较长期存活的对象。通常，将前一部分称为 **新生代**，后一部分称为 **老年代**

#### 4. `finalize()` 与 GC 过程

`finalize()` 是 `Object` 中的一个方法，而 `Object` 是所有类的父类。所以该方法存在于任意一个类。该方法的唯一作用就是在对象被 GC  时会调用它。接下来，我们通过下面的流程图具体了解 `finalize()` 在 GC 过程中发挥的作用。

![finalize 方法](https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2019-02-15/finalize.png "finalize 方法")

注意：
- 垃圾回收器会只会执行一次 `finalize()` 方法
- 垃圾回收器只保证该方法会被调用一次，但不保证会完整地执行完该方法。所以，不建议使用该方法（比如，善后等等）

#### 5. HotSpot 的 GC

上面是 GC 的一些理论，接下来，我们浅显地剖析 **HotSpot** 中的 GC。

垃圾收集的时机
- 首先，考虑标注操作的性能。为了 GC ，我们需要先找出堆中的所有对象引入。然而，堆大于百兆是很普遍的，若进行遍历查找会严重影响 GC 的速度。还有一点需要说明，GC 时需要 `stop the world` 的。怎么理解呢？就是在 GC 时需要暂停其他工作线程。所以，我们对 GC 的性能有很高的要求。
- 如何解决呢？我们使用一个称为 `OopMap` 的数据结构。`Oop` 即 ordinary object point，此数据结构维护了对象在堆中的信息。我们可以通过它很快的找到所有的引用。
- 接着，我们考虑 GC 线程要执行时，其他工作线程如何暂停。很显然，我们需要注意 `OopMap` 的维护。因为对象引用关系的变化全体现在此数据结构上。换句话说，我们可以操作 `OopMap` 的指令的前或后（一般，这样的地方称为 **安全点** ）暂停。这又会引出一个问题，操作 `OopMap` 的指令的频率。如果过多，会增大不必要的额外运行负荷。如果过少，会导致 GC 线程等待的时间较长。所以，安全点的选定基本上是以程序 *是否具有让程序长时间执行的特征* 为标准进行选定的。
- 简而言之，GC 线程需要所有的工作线程到达 **安全点** ，才能开始后续操作。 
- 最后，还有 安全区域 的概念，其实它是安全点的扩展。这里不再赘述。

各种垃圾收集器

![各种垃圾收集器](https://raw.githubusercontent.com/INotWant/INotWant.github.io/master/assets/images/2019-02-15/gcs.png "各种垃圾收集器")

| 收集器名称  | 年代 |  算法 | 线程 | 特点 |
| ---------- | ----------- | ----------- | ----------- | ----------- |
| Serial | 新生代 | 复制算法 | 单 | 适用于 Client 模式 |
| ParNew | 新生代 | 复制算法 | 多 | Serial 的多线程实现，可与 CMS 搭配 |
| Parallel Scavenge | 新生代 | 复制算法 | 多 | 注重吞吐量，可配置停顿时间 |
| Serial Old | 老年代 | 标记-整理 | 单 | 作为 CMS 的后备 |
| Parallel Old | 老年代 | 标记-整理 | 多 | 注重吞吐量 |
| CMS | 老年代 | 标记-清除 | 多 | 注重停顿时间，分为4阶段，浮动垃圾，内存碎片 |
| G1 | 新、老 | 标记-整理 | 多 | **化整为零**思想，可预期停顿时间,无碎片 |

由于篇幅有限，这里不再具体介绍各个垃圾收集器。推荐一篇文章：[**一文了解JVM全部垃圾回收器，从Serial到ZGC**](https://zhuanlan.zhihu.com/p/45581464)。

#### 附：Java 中的几种引用

- 强引用 --> 普通引用，永远不会被 GC
- 软引用 --> `SoftReference`，在将要 OOM 时，才被 GC 掉，如果仍不足，则抛出 OOM
- 弱引用 --> `WeakReference`，活不过 GC
- 虚引用 --> `PhantomReference`，不能用于获取对象，只是用于监控对象是否被 GC。GC 后会收到通知

## 内存分配策略

1. 对象优先在 `Eden`（新生代的一部分） 分配
2. 由于 **分配担保**，对象从新生代转移到老年代
3. 大对象直接在老年代分配
4. 长期存活的对象将进入老年代
5. 动态对象年龄判定（在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代）

附：`GC 日志` 解读
`33.125: [GC [DefNew: 3324k->152k(3712k), 0.0025925 secs] 3324k->152k(11904k), 0.0031680 secs]`
- 发生的时刻（从启动开始计时）
- `GC` or `Full GC`（发送了STW，即 stop-the-world） 表示垃圾收集的停顿类型
- `DefNew` 表示发生 GC 的位置（新生代 or 老年代），不同虚拟机不同
- `3324k->152k(3712k), 0.0025925 secs` --> 发生 GC 区域 GC 前所用空间，GC 后所用空间，所用时间
- `3324k->152k(11904k), 0.0031680 secs` --> 堆在 GC 前所用空间，GC 后所用空间，所用时间
